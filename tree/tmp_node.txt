#ifndef CPP2_S21_CONTAINERS_1_S21_TREE_NODE_H
#define CPP2_S21_CONTAINERS_1_S21_TREE_NODE_H

#include <iostream>
#include <utility>

namespace S21 {
    template <typename K, typename V>
    class Tree {
    public:
        using key_type = K;
        using mapped_type = V;
        using value_type = std::pair<key_type, mapped_type>;
        using reference = value_type &;
        using const_reference = const value_type &;
//        using iterator = MapIterator<K, T>; //or BinaryTree::iterator
//        using const_iterator = MapConstIterator<K, T>; //or BinaryTree::const_iterator
        using size_type = size_t;

        // CONSTRUCTORS
        Tree() noexcept;
        Tree(key_type k, mapped_type m) noexcept;
//        Tree(const Tree &other) noexcept;
//        Tree(Tree &&other);

        // DESTRUCTOR
        ~Tree() = default;
        // REFACTOR
//        ~Tree();

        // BASIC METHODS
        void Kek() { std::cout << "Key: " << root_->element_.first << " Value: " << root_->element_.second << std::endl; };
        void Insert(const value_type& elem);

    protected:
        typedef struct Node_ {
            Node_* left_;
            Node_* right_;
            value_type element_;
            unsigned char height_;
            Node_(key_type k, mapped_type m) : left_(nullptr), right_(nullptr), element_(k, m), height_(1) {};
        } Node_;

        Node_* root_;
//        value_type element_;
//        unsigned char height_;
        size_type size_;

    private:
        unsigned char Height_(Node_* tmp_root);
        int BalanceFactor_(Node_* tmp_root);
        void FixHeight_();
        void RotateLeft();
        void RotateRight();
//        void ChangePointers(Tree* tmp);
        void Balance_(Node_* tmp_root);
        void InsertNode_(Node_* tmp_node, const value_type& elem);
    };

    template<typename K, typename V>
    Tree<K, V>::Tree() noexcept : root_(nullptr), size_(0) {}

//    template<typename K, typename V>
//    Tree<K, V>::Tree(key_type k, mapped_type m) noexcept : root_(nullptr) {
//
//    }

    template<typename K, typename V>
    inline unsigned char Tree<K, V>::Height_(Node_* tmp_root) { return (tmp_root ? tmp_root->height_ : 0); }

    template<typename K, typename V>
    inline int Tree<K, V>::BalanceFactor_(Node_* tmp_root) { return (Height_(tmp_root->right_) - Height_(tmp_root->left_)); }

    template<typename K, typename V>
    void Tree<K, V>::FixHeight_() { root_->height_ = (Height_(root_->left_) > Height_(root_->right_) ? Height_(root_->left_) : Height_(root_->right_)) + 1; }

    template<typename K, typename V>
    void Tree<K, V>::RotateLeft() {
        Node_* tmp_right = root_->right_;
        root_->right_ = tmp_right->left_;
        tmp_right->left_ = root_;
        FixHeight_(root_);
        FixHeight_(tmp_right);
        tmp_right = root_;
//        ChangePointers(tmp_right);
    }

    template<typename K, typename V>
    void Tree<K, V>::RotateRight() {
        Node_* tmp_left = root_->left_;
        root_->left_ = tmp_left->right;
        tmp_left->right_ = root_;
        FixHeight_(root_);
        FixHeight_(tmp_left);
        tmp_left = root_;
    }

//    template<typename K, typename V>
//    void Tree<K, V>::ChangePointers(Tree* tmp) {
//        Tree* tmp_r = tmp->right_;
//        Tree* tmp_l = tmp->left_;
//        value_type tmp_v = element_;
//        size_type tmp_s = size_;
//        tmp->right_ = right_;
//        right_ = tmp_r;
//        tmp->left_ = left_;
//        left_ = tmp_l;
//        tmp->element_ = element_;
//        element_ = tmp_v;
//        tmp->size_ = size_;
//        size_ = tmp_s;
//    }

    template<typename K, typename V>
    void Tree<K, V>::Balance_(Node_* tmp_root) {
        FixHeight_();
        int balance = BalanceFactor_(root_);
        if (balance == 2) {
            if (BalanceFactor_(root_->right_) < 0) {
                RotateRight();
            }
            RotateLeft();
        } else if (balance == -2) {
            if (BalanceFactor_(root_->left_) > 0)
                RotateLeft();
            RotateRight();
        }
    }

    template<typename K, typename V>
    void Tree<K, V>::Insert(const value_type& elem) {
//        if (!root_) {
//            root_ = new Node_(elem.first, elem.second);
//            return;
//        }
//
//        if (elem.first < root_->element_.first) {
////            if (!root_->left_)
////                root_->left_ = new Node_(elem.first, elem.second);
////            else
//        } else if (elem.first > element_.first) {
//            if (!right_)
//                right_ = new Tree<K, V>(elem.first, elem.second);
//            else
//                right_->Insert(elem);
//        }
//
//        Balance_();
        InsertNode_(root_, elem);
    }

    template<typename K, typename V>
    void Tree<K, V>::InsertNode_(Tree::Node_ *tmp_node, const Tree::value_type &elem) {
        if (!root_) {
            root_ = new Node_(elem.first, elem.second);
            return;
        }

        if (elem.first < root_->element_.first) {
            InsertNode_(root_->left_, elem);
        } else if (elem.first > root_->element_.first) {
            InsertNode_(root_, elem);
        }

        Balance_();
    }

}

#endif  // CPP2_S21_CONTAINERS_1_S21_TREE_NODE_H

